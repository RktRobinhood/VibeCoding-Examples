<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web Photo Editor (v1) ‚Äî Canvas + WebGL</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:rgba(255,255,255,.05);
      --panel2:rgba(255,255,255,.03);
      --border:rgba(255,255,255,.12);
      --ink:#e9ecff;
      --muted:rgba(233,236,255,.72);
      --accent:rgba(124,58,237,.65);
      --blue:rgba(59,130,246,.6);
      --good:rgba(34,197,94,.55);
      --warn:rgba(251,191,36,.55);
      --bad:rgba(251,113,133,.55);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--ink);
      background:
        radial-gradient(1100px 700px at 15% 10%, rgba(124,58,237,0.35), transparent 60%),
        radial-gradient(1100px 700px at 85% 12%, rgba(59,130,246,0.25), transparent 58%),
        linear-gradient(180deg, #070a14, var(--bg));
    }
    a{color:#9ac6ff;text-decoration:none}
    a:hover{text-decoration:underline}

    header{max-width:1400px;margin:0 auto;padding:14px 16px 8px}
    .topnav{margin-bottom:8px}
    h1{margin:0;font-size:18px}
    .sub{margin:8px 0 0;color:var(--muted);font-size:13px;line-height:1.4;max-width:1100px}

    main{max-width:1400px;margin:0 auto;padding:10px 16px 24px;display:grid;grid-template-columns: 320px 1fr 340px;gap:12px;align-items:start}
    @media (max-width:1200px){main{grid-template-columns:1fr}}
    .panel{
      border:1px solid var(--border);
      border-radius:16px;
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      box-shadow:0 10px 35px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .ph{padding:12px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .ph h2{margin:0;font-size:13px;letter-spacing:.2px}
    .pb{padding:12px}

    button, input[type="text"], input[type="number"], select{
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--ink);
      border-radius:12px;
      padding:8px 10px;
      font-size:12px;
      outline:none;
    }
    button{cursor:pointer}
    button:hover{filter:brightness(1.07)}
    button.primary{background:rgba(124,58,237,.22);border-color:rgba(124,58,237,.55)}
    button.good{background:rgba(34,197,94,.16);border-color:rgba(34,197,94,.55)}
    button.warn{background:rgba(251,191,36,.14);border-color:rgba(251,191,36,.55)}
    button.bad{background:rgba(251,113,133,.14);border-color:rgba(251,113,133,.55)}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}

    .pill{display:inline-flex;gap:8px;align-items:center;font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,.04)}
    .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; padding:2px 6px;border:1px solid var(--border);border-radius:8px;background:rgba(255,255,255,0.05);font-size:12px}
    .hint{color:var(--muted);font-size:12px;line-height:1.4}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}

    /* Canvas area */
    .stageWrap{
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      background:rgba(0,0,0,.18);
    }
    .stageTop{
      padding:10px 12px;border-bottom:1px solid var(--border);
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
    }
    .stage{
      position:relative;
      width:100%;
      height:720px;
      background:
        linear-gradient(45deg, rgba(255,255,255,.05) 25%, transparent 25%, transparent 75%, rgba(255,255,255,.05) 75%, rgba(255,255,255,.05)),
        linear-gradient(45deg, rgba(255,255,255,.05) 25%, transparent 25%, transparent 75%, rgba(255,255,255,.05) 75%, rgba(255,255,255,.05));
      background-size: 24px 24px;
      background-position: 0 0, 12px 12px;
    }
    @media (max-width:1200px){.stage{height:560px}}
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block}
    #glCanvas{pointer-events:none;opacity:1}
    #uiCanvas{pointer-events:auto}
    .dropBadge{
      position:absolute;left:12px;bottom:12px;
      border:1px dashed rgba(255,255,255,.28);
      background:rgba(0,0,0,.25);
      color:rgba(233,236,255,.88);
      padding:10px 12px;border-radius:14px;font-size:12px;max-width:520px;
    }

    /* Layers */
    .layers{display:flex;flex-direction:column;gap:8px}
    .layer{
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(255,255,255,.03);
      padding:10px;
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px;
      align-items:center;
    }
    .layer.active{outline:2px solid rgba(124,58,237,.8);outline-offset:2px}
    .layer .title{display:flex;gap:8px;align-items:center;min-width:0}
    .layer input[type="text"]{width:100%;min-width:0}
    .layer .meta{display:flex;gap:8px;align-items:center;justify-content:flex-end}
    .miniBtn{padding:6px 8px;border-radius:10px}
    .slider{width:120px}

    /* Controls groups */
    .group{border:1px solid var(--border);border-radius:14px;padding:10px;background:rgba(255,255,255,.03)}
    .group h3{margin:0 0 8px;font-size:13px}
    .kv{display:grid;grid-template-columns: 140px 1fr;gap:8px;align-items:center;font-size:12px;color:rgba(233,236,255,.86)}
    .kv span{color:rgba(233,236,255,.7)}
    input[type="range"]{width:100%}
  </style>
</head>
<body>
  <header>
    <nav class="topnav"><a href="../../index.html">‚Üê Back to projects</a></nav>
    <h1>Web Photo Editor (v1) ‚Äî Canvas + WebGL</h1>
    <p class="sub">
      GitHub Pages‚Äìfriendly Photoshop-style editor: layers, brush/eraser/shapes/text, pan/zoom, undo/redo, and fast WebGL filters.
      Use <span class="kbd">Space</span>+drag to pan, mousewheel to zoom. Drag an image onto the canvas to import.
    </p>
  </header>

  <main>
    <!-- LEFT: Tools + Layers -->
    <section class="panel">
      <div class="ph">
        <h2>Tools & layers</h2>
        <div class="row">
          <button id="btnImport" class="primary">Import</button>
          <input id="fileInput" type="file" accept="image/*" style="display:none" />
        </div>
      </div>
      <div class="pb">
        <div class="group">
          <h3>Tools</h3>
          <div class="row" style="margin-bottom:8px">
            <button id="toolMove" class="primary">Move</button>
            <button id="toolBrush">Brush</button>
            <button id="toolEraser">Eraser</button>
            <button id="toolRect">Rect</button>
            <button id="toolEllipse">Ellipse</button>
            <button id="toolText">Text</button>
          </div>

          <div class="kv"><span>Brush size</span><input id="brushSize" type="range" min="1" max="80" value="14" /></div>
          <div class="kv"><span>Brush hardness</span><input id="brushHard" type="range" min="0" max="100" value="70" /></div>
          <div class="kv"><span>Opacity</span><input id="brushOpacity" type="range" min="1" max="100" value="90" /></div>
          <div class="kv"><span>Color</span>
            <div class="row" style="justify-content:space-between">
              <input id="colorPick" type="color" value="#ffffff" />
              <span class="pill mono" id="colorHex">#ffffff</span>
            </div>
          </div>
          <div class="hint" style="margin-top:8px">
            Undo: <span class="kbd">Ctrl/‚åò</span>+<span class="kbd">Z</span> ‚Ä¢ Redo: <span class="kbd">Ctrl/‚åò</span>+<span class="kbd">Shift</span>+<span class="kbd">Z</span>
          </div>
        </div>

        <div class="group" style="margin-top:10px">
          <div class="row" style="justify-content:space-between;align-items:center">
            <h3 style="margin:0">Layers</h3>
            <div class="row">
              <button id="btnNewLayer" class="good miniBtn">+ Layer</button>
            </div>
          </div>
          <div class="layers" id="layers"></div>
          <div class="hint" style="margin-top:8px">
            Tip: keep the base image on a locked layer and draw on top.
          </div>
        </div>
      </div>
    </section>

    <!-- CENTER: Stage -->
    <section class="panel stageWrap">
      <div class="stageTop">
        <div class="row">
          <button id="btnUndo">Undo</button>
          <button id="btnRedo">Redo</button>
          <button id="btnExport" class="good">Export PNG</button>
          <button id="btnResetView" class="warn">Reset view</button>
        </div>
        <div class="row">
          <span class="pill">Zoom: <span class="mono" id="zoomLabel">100%</span></span>
          <span class="pill">Canvas: <span class="mono" id="sizeLabel">‚Äî</span></span>
        </div>
      </div>
      <div class="stage" id="stage">
        <!-- We draw into a 2D offscreen composite, then WebGL renders filtered output to glCanvas. -->
        <canvas id="glCanvas"></canvas>
        <!-- UI canvas handles interactions and also draws the unfiltered view while editing,
             but we‚Äôll still show the filtered output underneath for ‚ÄúPhotoshop feel‚Äù. -->
        <canvas id="uiCanvas"></canvas>

        <div class="dropBadge" id="dropBadge">
          Drop an image here to import. <span class="mono">PNG/JPG</span>.  
          Pan: <span class="kbd">Space</span>+drag ‚Ä¢ Zoom: mouse wheel ‚Ä¢ Double-click text tool to place text.
        </div>
      </div>
    </section>

    <!-- RIGHT: Filters -->
    <section class="panel">
      <div class="ph">
        <h2>WebGL filters</h2>
        <div class="row">
          <button id="btnBypass">Bypass</button>
          <button id="btnResetFilters" class="warn">Reset</button>
        </div>
      </div>
      <div class="pb">
        <div class="group">
          <h3>Adjustments</h3>
          <div class="kv"><span>Brightness</span><input id="fBright" type="range" min="-1" max="1" value="0" step="0.01"></div>
          <div class="kv"><span>Contrast</span><input id="fContrast" type="range" min="-1" max="1" value="0" step="0.01"></div>
          <div class="kv"><span>Saturation</span><input id="fSat" type="range" min="-1" max="2" value="0" step="0.01"></div>
          <div class="kv"><span>Hue</span><input id="fHue" type="range" min="-3.1416" max="3.1416" value="0" step="0.01"></div>
        </div>

        <div class="group" style="margin-top:10px">
          <h3>Effects</h3>
          <div class="kv"><span>Blur</span><input id="fBlur" type="range" min="0" max="8" value="0" step="0.1"></div>
          <div class="row" style="margin-top:8px">
            <label class="pill"><input id="fGray" type="checkbox"> Grayscale</label>
            <label class="pill"><input id="fInvert" type="checkbox"> Invert</label>
          </div>
          <div class="hint" style="margin-top:8px">
            Filters apply to the full composite (v1). Next iteration can add per-layer filters + masks.
          </div>
        </div>

        <div class="group" style="margin-top:10px">
          <h3>IB student uses</h3>
          <div class="hint">
            ‚Ä¢ Annotate IA diagrams and lab photos (arrows/text).<br>
            ‚Ä¢ Build ‚Äúbefore/after‚Äù image analysis quickly with filters.<br>
            ‚Ä¢ Create posters and visual study guides with layered assets.
          </div>
        </div>
      </div>
    </section>
  </main>

<script>
/* ============================================================
   Web Photo Editor v1 (Canvas 2D + WebGL)
   - Layers: raster layers backed by offscreen canvases
   - UI canvas: interaction, previews, selection handles
   - Composite canvas: offscreen merge of visible layers
   - WebGL: draws composite texture with shader adjustments
   ============================================================ */

const $ = (s)=>document.querySelector(s);
const stage = $("#stage");
const glCanvas = $("#glCanvas");
const uiCanvas = $("#uiCanvas");
const ctxUI = uiCanvas.getContext("2d", { alpha: true });

const btnImport = $("#btnImport");
const fileInput = $("#fileInput");
const btnNewLayer = $("#btnNewLayer");
const layersEl = $("#layers");

const toolMove = $("#toolMove");
const toolBrush = $("#toolBrush");
const toolEraser = $("#toolEraser");
const toolRect = $("#toolRect");
const toolEllipse = $("#toolEllipse");
const toolText = $("#toolText");

const brushSize = $("#brushSize");
const brushHard = $("#brushHard");
const brushOpacity = $("#brushOpacity");
const colorPick = $("#colorPick");
const colorHex = $("#colorHex");

const btnUndo = $("#btnUndo");
const btnRedo = $("#btnRedo");
const btnExport = $("#btnExport");
const btnResetView = $("#btnResetView");
const zoomLabel = $("#zoomLabel");
const sizeLabel = $("#sizeLabel");
const dropBadge = $("#dropBadge");

const btnBypass = $("#btnBypass");
const btnResetFilters = $("#btnResetFilters");
const fBright = $("#fBright");
const fContrast = $("#fContrast");
const fSat = $("#fSat");
const fHue = $("#fHue");
const fBlur = $("#fBlur");
const fGray = $("#fGray");
const fInvert = $("#fInvert");

let TOOL = "move"; // move|brush|eraser|rect|ellipse|text
let bypass = false;

// World/canvas coordinate system for document
// We'll maintain a "document" size (w,h). If you import an image, we size doc to that image initially.
const doc = {
  w: 1200,
  h: 800,
};

// View transform (screen <-> doc)
const view = {
  zoom: 1,
  panX: 0,
  panY: 0,
  isPanning: false,
  panStart: {x:0,y:0, px:0, py:0},
};

function setZoom(z){
  view.zoom = Math.max(0.1, Math.min(8, z));
  zoomLabel.textContent = Math.round(view.zoom * 100) + "%";
  requestRender();
}
function resetView(){
  view.zoom = 1;
  view.panX = 0;
  view.panY = 0;
  zoomLabel.textContent = "100%";
  requestRender();
}
btnResetView.addEventListener("click", resetView);

// Layers (each raster layer: offscreen canvas)
const layers = [];
let activeLayerId = null;

function newLayer(name="Layer"){
  const id = cryptoId();
  const c = document.createElement("canvas");
  c.width = doc.w; c.height = doc.h;
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);

  const layer = {
    id, name,
    canvas: c,
    ctx,
    visible: true,
    locked: false,
    opacity: 1,
    // Transform at layer level (v1: simple translate/scale/rotate would be next; for now just translate)
    x: 0,
    y: 0,
  };
  layers.unshift(layer); // top-most at start
  activeLayerId = id;
  snapshot("new layer");
  renderLayersUI();
  requestRender();
  return layer;
}

function getActiveLayer(){
  return layers.find(l => l.id === activeLayerId) || layers[0];
}

function renderLayersUI(){
  layersEl.innerHTML = "";
  for (const l of layers){
    const row = document.createElement("div");
    row.className = "layer" + (l.id===activeLayerId ? " active" : "");
    row.innerHTML = `
      <div class="title">
        <button class="miniBtn" data-act="vis" title="Show/hide">${l.visible ? "üëÅ" : "üö´"}</button>
        <input type="text" value="${escapeHtml(l.name)}" data-act="name" />
      </div>
      <div class="meta">
        <label class="pill" title="Opacity"><span class="mono">${Math.round(l.opacity*100)}%</span>
          <input class="slider" type="range" min="0" max="100" value="${Math.round(l.opacity*100)}" data-act="op"/>
        </label>
        <button class="miniBtn" data-act="up" title="Move up">‚Üë</button>
        <button class="miniBtn" data-act="dn" title="Move down">‚Üì</button>
        <button class="miniBtn" data-act="lock" title="Lock/unlock">${l.locked ? "üîí" : "üîì"}</button>
        <button class="miniBtn bad" data-act="del" title="Delete">‚úï</button>
      </div>
    `;

    row.addEventListener("click", (e)=>{
      // ignore clicks on inputs/buttons that act locally
      if (e.target && (e.target.tagName==="INPUT" || e.target.tagName==="BUTTON" || e.target.closest("button"))) return;
      activeLayerId = l.id;
      renderLayersUI();
      requestRender();
    });

    row.querySelectorAll("button, input").forEach(el=>{
      el.addEventListener("click", (e)=>e.stopPropagation());
      el.addEventListener("input", (e)=>e.stopPropagation());
    });

    // Actions
    row.querySelector('[data-act="vis"]').addEventListener("click", ()=>{
      l.visible = !l.visible;
      renderLayersUI();
      requestRender();
    });
    row.querySelector('[data-act="lock"]').addEventListener("click", ()=>{
      l.locked = !l.locked;
      renderLayersUI();
    });
    row.querySelector('[data-act="del"]').addEventListener("click", ()=>{
      if (layers.length<=1) return alert("Keep at least one layer.");
      const idx = layers.findIndex(x=>x.id===l.id);
      layers.splice(idx,1);
      if (activeLayerId===l.id) activeLayerId = layers[0].id;
      snapshot("delete layer");
      renderLayersUI();
      requestRender();
    });
    row.querySelector('[data-act="up"]').addEventListener("click", ()=>{
      const idx = layers.findIndex(x=>x.id===l.id);
      if (idx<=0) return;
      [layers[idx-1], layers[idx]] = [layers[idx], layers[idx-1]];
      snapshot("reorder");
      renderLayersUI();
      requestRender();
    });
    row.querySelector('[data-act="dn"]').addEventListener("click", ()=>{
      const idx = layers.findIndex(x=>x.id===l.id);
      if (idx<0 || idx>=layers.length-1) return;
      [layers[idx+1], layers[idx]] = [layers[idx], layers[idx+1]];
      snapshot("reorder");
      renderLayersUI();
      requestRender();
    });
    row.querySelector('[data-act="op"]').addEventListener("input", (e)=>{
      l.opacity = Number(e.target.value)/100;
      renderLayersUI();
      requestRender();
    });
    row.querySelector('[data-act="name"]').addEventListener("input", (e)=>{
      l.name = e.target.value.slice(0,60);
    });

    // Activate on click anywhere
    row.addEventListener("mousedown", ()=>{
      activeLayerId = l.id;
      renderLayersUI();
      requestRender();
    });

    layersEl.appendChild(row);
  }
}

// Composite offscreen canvas (merged visible layers)
const composite = document.createElement("canvas");
const ctxC = composite.getContext("2d");

// Resize document + all layer canvases
function resizeDocument(w,h, preserve=true){
  doc.w = Math.max(1, Math.floor(w));
  doc.h = Math.max(1, Math.floor(h));
  sizeLabel.textContent = `${doc.w}√ó${doc.h}`;

  composite.width = doc.w;
  composite.height = doc.h;

  for (const l of layers){
    const old = l.canvas;
    const oldCtx = l.ctx;
    const c = document.createElement("canvas");
    c.width = doc.w; c.height = doc.h;
    const ctx = c.getContext("2d");
    if (preserve){
      ctx.drawImage(old, 0,0);
    }
    l.canvas = c;
    l.ctx = ctx;
  }
  requestRender();
}

// History (simple snapshots: layer raster + settings)
const history = {
  undo: [],
  redo: [],
  max: 25
};

function snapshot(reason="edit"){
  // Capture layer images as dataURLs (v1: OK; not ideal for huge docs)
  const state = {
    doc: {w:doc.w, h:doc.h},
    layers: layers.map(l => ({
      id: l.id,
      name: l.name,
      visible: l.visible,
      locked: l.locked,
      opacity: l.opacity,
      x: l.x, y: l.y,
      png: l.canvas.toDataURL("image/png")
    })),
    activeLayerId,
    reason,
  };
  history.undo.push(state);
  if (history.undo.length > history.max) history.undo.shift();
  history.redo = [];
  updateUndoRedoButtons();
}

function applyState(state){
  resizeDocument(state.doc.w, state.doc.h, false);
  layers.length = 0;

  for (const L of state.layers){
    const c = document.createElement("canvas");
    c.width = doc.w; c.height = doc.h;
    const ctx = c.getContext("2d");
    const layer = {
      id: L.id,
      name: L.name,
      visible: L.visible,
      locked: L.locked,
      opacity: L.opacity,
      x: L.x, y: L.y,
      canvas: c,
      ctx,
    };
    layers.push(layer);
  }

  // Load images async, then render
  let remaining = state.layers.length;
  state.layers.forEach((L, idx)=>{
    const img = new Image();
    img.onload = ()=>{
      layers[idx].ctx.clearRect(0,0,doc.w,doc.h);
      layers[idx].ctx.drawImage(img,0,0);
      remaining--;
      if (remaining===0){
        activeLayerId = state.activeLayerId;
        renderLayersUI();
        requestRender();
      }
    };
    img.src = L.png;
  });

  sizeLabel.textContent = `${doc.w}√ó${doc.h}`;
}

function undo(){
  if (history.undo.length <= 1) return; // keep initial
  const cur = history.undo.pop();
  history.redo.push(cur);
  const prev = history.undo[history.undo.length-1];
  applyState(prev);
  updateUndoRedoButtons();
}
function redo(){
  if (!history.redo.length) return;
  const s = history.redo.pop();
  history.undo.push(s);
  applyState(s);
  updateUndoRedoButtons();
}
function updateUndoRedoButtons(){
  btnUndo.disabled = history.undo.length<=1;
  btnRedo.disabled = history.redo.length===0;
}
btnUndo.addEventListener("click", undo);
btnRedo.addEventListener("click", redo);

// Keybinds
window.addEventListener("keydown", (e)=>{
  const isMac = navigator.platform.toLowerCase().includes("mac");
  const mod = isMac ? e.metaKey : e.ctrlKey;
  if (mod && e.key.toLowerCase()==="z" && !e.shiftKey){ e.preventDefault(); undo(); }
  if (mod && (e.key.toLowerCase()==="z") && e.shiftKey){ e.preventDefault(); redo(); }
  if (e.code==="Space" && !e.repeat){
    view.isPanning = true;
  }
});
window.addEventListener("keyup", (e)=>{
  if (e.code==="Space"){ view.isPanning = false; }
});

// Tool switching
function setTool(t){
  TOOL = t;
  [toolMove,toolBrush,toolEraser,toolRect,toolEllipse,toolText].forEach(b=>b.classList.remove("primary"));
  ({
    move: toolMove,
    brush: toolBrush,
    eraser: toolEraser,
    rect: toolRect,
    ellipse: toolEllipse,
    text: toolText
  }[t]).classList.add("primary");
  requestRender();
}
toolMove.onclick=()=>setTool("move");
toolBrush.onclick=()=>setTool("brush");
toolEraser.onclick=()=>setTool("eraser");
toolRect.onclick=()=>setTool("rect");
toolEllipse.onclick=()=>setTool("ellipse");
toolText.onclick=()=>setTool("text");

btnNewLayer.addEventListener("click", ()=>{
  newLayer(`Layer ${layers.length+1}`);
});

// Color
colorPick.addEventListener("input", ()=>{
  colorHex.textContent = colorPick.value.toLowerCase();
});

// Import
btnImport.addEventListener("click", ()=>fileInput.click());
fileInput.addEventListener("change", async ()=>{
  const f = fileInput.files?.[0];
  if (!f) return;
  await importImageFile(f);
  fileInput.value = "";
});

async function importImageFile(file){
  const url = URL.createObjectURL(file);
  const img = await loadImage(url);
  URL.revokeObjectURL(url);

  // If first import, size doc to image and create base layer
  if (layers.length===1 && isLayerEmpty(layers[0])) {
    resizeDocument(img.width, img.height, false);
  }

  const layer = newLayer(file.name.replace(/\.[^.]+$/,""));
  layer.ctx.clearRect(0,0,doc.w,doc.h);

  // Fit image into doc at (0,0) (v1). If image larger, crop.
  layer.ctx.drawImage(img, 0,0);
  layer.locked = false;
  activeLayerId = layer.id;

  dropBadge.style.display = "none";
  renderLayersUI();
  snapshot("import");
  requestRender();
}

function isLayerEmpty(layer){
  const img = layer.ctx.getImageData(0,0,Math.min(32,doc.w),Math.min(32,doc.h)).data;
  for (let i=3;i<img.length;i+=4) if (img[i]!==0) return false;
  return true;
}

function loadImage(src){
  return new Promise((res,rej)=>{
    const im = new Image();
    im.onload=()=>res(im);
    im.onerror=rej;
    im.src = src;
  });
}

// Drag/drop import
stage.addEventListener("dragover", (e)=>{ e.preventDefault(); });
stage.addEventListener("drop", async (e)=>{
  e.preventDefault();
  const f = e.dataTransfer?.files?.[0];
  if (f && f.type.startsWith("image/")){
    await importImageFile(f);
  }
});

// Export (filtered output)
btnExport.addEventListener("click", ()=>{
  // Ensure latest composite->WebGL render, then extract gl canvas pixels
  renderComposite();
  renderGL();
  const link = document.createElement("a");
  link.download = "export.png";
  link.href = glCanvas.toDataURL("image/png");
  link.click();
});

// ============================================================
// Coordinate transforms
// ============================================================
function screenToDoc(x,y){
  // x,y in UI canvas pixels
  const cx = uiCanvas.clientWidth/2;
  const cy = uiCanvas.clientHeight/2;
  const dx = (x - cx - view.panX) / view.zoom + doc.w/2;
  const dy = (y - cy - view.panY) / view.zoom + doc.h/2;
  return {x:dx, y:dy};
}
function docToScreen(x,y){
  const cx = uiCanvas.clientWidth/2;
  const cy = uiCanvas.clientHeight/2;
  const sx = (x - doc.w/2) * view.zoom + cx + view.panX;
  const sy = (y - doc.h/2) * view.zoom + cy + view.panY;
  return {x:sx, y:sy};
}

// ============================================================
// Drawing / interaction
// ============================================================
let mouse = {down:false, x:0,y:0, lastX:0,lastY:0};
let dragLayer = null;
let shapeStart = null;
let shapePreview = null;

uiCanvas.addEventListener("wheel", (e)=>{
  e.preventDefault();
  const delta = Math.sign(e.deltaY);
  const factor = delta>0 ? 0.92 : 1.08;
  setZoom(view.zoom * factor);
},{passive:false});

uiCanvas.addEventListener("mousedown", (e)=>{
  mouse.down = true;
  mouse.x = mouse.lastX = e.offsetX;
  mouse.y = mouse.lastY = e.offsetY;

  if (view.isPanning){
    view.panStart = {x:e.clientX,y:e.clientY, px:view.panX, py:view.panY};
    return;
  }

  const a = getActiveLayer();
  if (!a || a.locked) return;

  if (TOOL==="move"){
    dragLayer = a;
  } else if (TOOL==="brush" || TOOL==="eraser"){
    drawStrokeToLayer(a, e.offsetX, e.offsetY, true);
  } else if (TOOL==="rect" || TOOL==="ellipse"){
    shapeStart = {sx:e.offsetX, sy:e.offsetY};
    shapePreview = null;
  } else if (TOOL==="text"){
    // place text on double click (or single click prompt)
    // We'll support double click by using detail=2 from click; simpler: on mousedown open prompt.
  }
});

uiCanvas.addEventListener("mousemove", (e)=>{
  mouse.x = e.offsetX;
  mouse.y = e.offsetY;

  if (mouse.down && view.isPanning){
    const dx = e.clientX - view.panStart.x;
    const dy = e.clientY - view.panStart.y;
    view.panX = view.panStart.px + dx;
    view.panY = view.panStart.py + dy;
    requestRender();
    return;
  }

  if (!mouse.down) { requestRender(); return; }

  const a = getActiveLayer();
  if (!a || a.locked) return;

  if (TOOL==="move" && dragLayer){
    // Move layer by screen delta transformed to doc delta
    const dScreenX = e.offsetX - mouse.lastX;
    const dScreenY = e.offsetY - mouse.lastY;
    dragLayer.x += dScreenX / view.zoom;
    dragLayer.y += dScreenY / view.zoom;
    requestRender();
  } else if (TOOL==="brush" || TOOL==="eraser"){
    drawStrokeToLayer(a, e.offsetX, e.offsetY, false);
  } else if ((TOOL==="rect" || TOOL==="ellipse") && shapeStart){
    shapePreview = {ex:e.offsetX, ey:e.offsetY};
    requestRender();
  }

  mouse.lastX = e.offsetX;
  mouse.lastY = e.offsetY;
});

uiCanvas.addEventListener("mouseup", (e)=>{
  mouse.down = false;
  dragLayer = null;

  const a = getActiveLayer();

  if ((TOOL==="rect" || TOOL==="ellipse") && shapeStart && shapePreview && a && !a.locked){
    commitShape(a, shapeStart, shapePreview, TOOL);
    shapeStart = null;
    shapePreview = null;
    snapshot("shape");
  } else {
    shapeStart = null;
    shapePreview = null;
  }

  if (TOOL==="brush" || TOOL==="eraser"){
    snapshot("stroke");
  }
  if (TOOL==="move"){
    snapshot("move");
  }
});

uiCanvas.addEventListener("dblclick", (e)=>{
  if (TOOL!=="text") return;
  const a = getActiveLayer();
  if (!a || a.locked) return;

  const text = prompt("Text:", "Label");
  if (!text) return;

  const docPt = screenToDoc(e.offsetX, e.offsetY);
  a.ctx.save();
  a.ctx.globalAlpha = (Number(brushOpacity.value)/100);
  a.ctx.fillStyle = colorPick.value;
  a.ctx.font = `700 ${Math.max(12, Number(brushSize.value)+6)}px ui-sans-serif, system-ui`;
  a.ctx.textBaseline = "top";
  a.ctx.fillText(text, docPt.x - a.x, docPt.y - a.y);
  a.ctx.restore();

  snapshot("text");
  requestRender();
});

// Stroke rendering (soft brush)
function drawStrokeToLayer(layer, sx, sy, isStart){
  const docPt = screenToDoc(sx, sy);
  const x = docPt.x - layer.x;
  const y = docPt.y - layer.y;

  const size = Number(brushSize.value);
  const hard = Number(brushHard.value)/100;
  const alpha = Number(brushOpacity.value)/100;

  layer.ctx.save();
  layer.ctx.globalAlpha = alpha;
  layer.ctx.lineCap = "round";
  layer.ctx.lineJoin = "round";

  if (TOOL==="eraser"){
    layer.ctx.globalCompositeOperation = "destination-out";
    layer.ctx.strokeStyle = "rgba(0,0,0,1)";
  } else {
    layer.ctx.globalCompositeOperation = "source-over";
    layer.ctx.strokeStyle = colorPick.value;
  }

  layer.ctx.lineWidth = size;

  if (isStart){
    layer._last = {x,y};
    // dab
    softDab(layer.ctx, x,y, size, hard, (TOOL==="eraser"));
  } else {
    const last = layer._last || {x,y};
    layer.ctx.beginPath();
    layer.ctx.moveTo(last.x, last.y);
    layer.ctx.lineTo(x,y);
    layer.ctx.stroke();
    softDab(layer.ctx, x,y, size, hard, (TOOL==="eraser"));
    layer._last = {x,y};
  }

  layer.ctx.restore();
  requestRender();
}

// Soft dab by drawing radial gradient circle (cheap)
function softDab(ctx, x,y, size, hard, erasing){
  const r = size/2;
  const g = ctx.createRadialGradient(x,y, r*hard, x,y, r);
  if (erasing){
    // in destination-out mode, alpha drives erase
    g.addColorStop(0, "rgba(0,0,0,1)");
    g.addColorStop(1, "rgba(0,0,0,0)");
  } else {
    const c = colorPick.value;
    g.addColorStop(0, hexToRgba(c, 1));
    g.addColorStop(1, hexToRgba(c, 0));
  }
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fill();
}

function hexToRgba(hex,a){
  const m = hex.replace("#","").match(/.{1,2}/g);
  const [r,g,b] = m.map(x=>parseInt(x,16));
  return `rgba(${r},${g},${b},${a})`;
}

function commitShape(layer, start, end, kind){
  const p1 = screenToDoc(start.sx, start.sy);
  const p2 = screenToDoc(end.ex, end.ey);

  const x1 = Math.min(p1.x,p2.x) - layer.x;
  const y1 = Math.min(p1.y,p2.y) - layer.y;
  const x2 = Math.max(p1.x,p2.x) - layer.x;
  const y2 = Math.max(p1.y,p2.y) - layer.y;

  const alpha = Number(brushOpacity.value)/100;
  layer.ctx.save();
  layer.ctx.globalAlpha = alpha;
  layer.ctx.globalCompositeOperation = "source-over";
  layer.ctx.strokeStyle = colorPick.value;
  layer.ctx.lineWidth = Math.max(2, Number(brushSize.value)/6);

  if (kind==="rect"){
    layer.ctx.strokeRect(x1,y1,x2-x1,y2-y1);
  } else {
    // ellipse
    layer.ctx.beginPath();
    layer.ctx.ellipse((x1+x2)/2,(y1+y2)/2, Math.abs(x2-x1)/2, Math.abs(y2-y1)/2, 0, 0, Math.PI*2);
    layer.ctx.stroke();
  }
  layer.ctx.restore();
  requestRender();
}

// ============================================================
// Rendering pipeline
// - renderComposite(): merge layers into composite canvas
// - upload composite to WebGL texture
// - shader draws to glCanvas with filters
// - ui canvas draws overlays (shape preview etc.)
// ============================================================

function renderComposite(){
  composite.width = doc.w;
  composite.height = doc.h;
  ctxC.clearRect(0,0,doc.w,doc.h);
  ctxC.save();
  // Background transparent; checkerboard is UI only.
  // Merge from bottom -> top (layers array is top-first; draw reverse)
  for (const l of [...layers].reverse()){
    if (!l.visible) continue;
    ctxC.globalAlpha = l.opacity;
    ctxC.drawImage(l.canvas, l.x, l.y);
  }
  ctxC.restore();
}

// UI overlays (shape preview)
function renderUI(){
  const W = uiCanvas.clientWidth;
  const H = uiCanvas.clientHeight;
  ctxUI.clearRect(0,0,W,H);

  // draw a faint bounding box of document area
  const tl = docToScreen(0,0);
  const br = docToScreen(doc.w, doc.h);
  ctxUI.save();
  ctxUI.strokeStyle = "rgba(233,236,255,0.28)";
  ctxUI.lineWidth = 1;
  ctxUI.strokeRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);
  ctxUI.restore();

  // shape preview
  if (shapeStart && shapePreview){
    const p1 = screenToDoc(shapeStart.sx, shapeStart.sy);
    const p2 = screenToDoc(shapePreview.ex, shapePreview.ey);

    const x1 = Math.min(p1.x,p2.x);
    const y1 = Math.min(p1.y,p2.y);
    const x2 = Math.max(p1.x,p2.x);
    const y2 = Math.max(p1.y,p2.y);

    const s1 = docToScreen(x1,y1);
    const s2 = docToScreen(x2,y2);

    ctxUI.save();
    ctxUI.strokeStyle = "rgba(251,191,36,0.9)";
    ctxUI.lineWidth = 2;
    if (TOOL==="rect"){
      ctxUI.strokeRect(s1.x,s1.y,s2.x-s1.x,s2.y-s1.y);
    } else if (TOOL==="ellipse"){
      ctxUI.beginPath();
      ctxUI.ellipse((s1.x+s2.x)/2,(s1.y+s2.y)/2, Math.abs(s2.x-s1.x)/2, Math.abs(s2.y-s1.y)/2, 0, 0, Math.PI*2);
      ctxUI.stroke();
    }
    ctxUI.restore();
  }

  // cursor hint
  ctxUI.save();
  ctxUI.fillStyle = "rgba(233,236,255,0.75)";
  ctxUI.font = "12px ui-sans-serif, system-ui";
  ctxUI.textAlign = "left";
  ctxUI.fillText(`Tool: ${TOOL.toUpperCase()}${view.isPanning ? " (PANNING)" : ""}`, 12, 18);
  ctxUI.fillText(`Layer: ${getActiveLayer()?.name ?? "‚Äî"}`, 12, 36);
  ctxUI.restore();
}

// ============================================================
// WebGL setup (single-pass with optional blur sampling)
// ============================================================
let gl, prog, vao, tex, uni;
function initGL(){
  gl = glCanvas.getContext("webgl2", { premultipliedAlpha: true, alpha: true });
  if (!gl){
    alert("WebGL2 not supported on this browser. Switch to option A (Canvas-only) if needed.");
    return;
  }

  const vs = `#version 300 es
  precision highp float;
  in vec2 a_pos;
  out vec2 v_uv;
  void main(){
    v_uv = (a_pos + 1.0) * 0.5;
    gl_Position = vec4(a_pos, 0.0, 1.0);
  }`;

  const fs = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  out vec4 outColor;
  uniform sampler2D u_tex;
  uniform vec2 u_texSize;

  uniform float u_bypass;
  uniform float u_brightness; // -1..1
  uniform float u_contrast;   // -1..1
  uniform float u_saturation; // -1..2 (offset model)
  uniform float u_hue;        // radians
  uniform float u_blur;       // px radius (0..8)
  uniform float u_gray;       // 0/1
  uniform float u_invert;     // 0/1

  // Hue rotation matrix
  mat3 hueMat(float a){
    float c = cos(a);
    float s = sin(a);
    // YIQ-ish approximation for rotation
    mat3 m = mat3(
      0.299, 0.587, 0.114,
      0.596, -0.274, -0.322,
      0.211, -0.523, 0.312
    );
    mat3 inv = inverse(m);
    mat3 rot = mat3(
      1.0, 0.0, 0.0,
      0.0, c, -s,
      0.0, s,  c
    );
    return inv * rot * m;
  }

  vec3 applyAdjust(vec3 col){
    // brightness
    col += u_brightness;

    // contrast (centered at 0.5)
    float c = u_contrast + 1.0;
    col = (col - 0.5) * c + 0.5;

    // saturation
    float l = dot(col, vec3(0.2126,0.7152,0.0722));
    col = mix(vec3(l), col, (u_saturation + 1.0)); // saturation slider as offset

    // hue rotate
    col = hueMat(u_hue) * col;

    // grayscale
    if (u_gray > 0.5){
      float g = dot(col, vec3(0.2126,0.7152,0.0722));
      col = vec3(g);
    }

    // invert
    if (u_invert > 0.5){
      col = vec3(1.0) - col;
    }

    return col;
  }

  vec4 sampleTex(vec2 uv){
    return texture(u_tex, uv);
  }

  void main(){
    vec2 uv = v_uv;

    vec4 base = sampleTex(uv);

    if (u_bypass > 0.5){
      outColor = base;
      return;
    }

    // lightweight blur: 9 taps max (cross + diagonals), scaled by u_blur
    vec4 col = base;
    if (u_blur > 0.001){
      vec2 px = 1.0 / u_texSize;
      float r = u_blur;
      vec2 o1 = px * r;
      vec2 o2 = px * r * 0.7071;

      vec4 s = sampleTex(uv) * 0.24;
      s += sampleTex(uv + vec2( o1.x, 0.0)) * 0.12;
      s += sampleTex(uv + vec2(-o1.x, 0.0)) * 0.12;
      s += sampleTex(uv + vec2(0.0,  o1.y)) * 0.12;
      s += sampleTex(uv + vec2(0.0, -o1.y)) * 0.12;

      s += sampleTex(uv + vec2( o2.x,  o2.y)) * 0.07;
      s += sampleTex(uv + vec2(-o2.x,  o2.y)) * 0.07;
      s += sampleTex(uv + vec2( o2.x, -o2.y)) * 0.07;
      s += sampleTex(uv + vec2(-o2.x, -o2.y)) * 0.07;
      col = s;
    }

    vec3 adj = applyAdjust(col.rgb);
    outColor = vec4(adj, col.a);
  }`;

  prog = createProgram(gl, vs, fs);
  gl.useProgram(prog);

  // Fullscreen quad
  vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1, -1, 1,
    -1, 1,  1,-1,  1, 1
  ]), gl.STATIC_DRAW);

  const loc = gl.getAttribLocation(prog, "a_pos");
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

  tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  uni = {
    texSize: gl.getUniformLocation(prog, "u_texSize"),
    bypass: gl.getUniformLocation(prog, "u_bypass"),
    bright: gl.getUniformLocation(prog, "u_brightness"),
    contrast: gl.getUniformLocation(prog, "u_contrast"),
    sat: gl.getUniformLocation(prog, "u_saturation"),
    hue: gl.getUniformLocation(prog, "u_hue"),
    blur: gl.getUniformLocation(prog, "u_blur"),
    gray: gl.getUniformLocation(prog, "u_gray"),
    invert: gl.getUniformLocation(prog, "u_invert"),
  };

  gl.uniform1i(gl.getUniformLocation(prog,"u_tex"), 0);
}

// Upload composite canvas to texture (doc size)
function uploadComposite(){
  if (!gl) return;
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, composite);
  gl.uniform2f(uni.texSize, composite.width, composite.height);
}

function renderGL(){
  if (!gl) return;

  // Fit GL canvas to stage size
  const rect = stage.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  glCanvas.width = Math.floor(rect.width * dpr);
  glCanvas.height = Math.floor(rect.height * dpr);

  gl.viewport(0,0,glCanvas.width, glCanvas.height);
  gl.clearColor(0,0,0,0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // Set uniforms
  gl.useProgram(prog);
  gl.bindVertexArray(vao);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, tex);

  gl.uniform1f(uni.bypass, bypass ? 1 : 0);
  gl.uniform1f(uni.bright, Number(fBright.value));
  gl.uniform1f(uni.contrast, Number(fContrast.value));
  gl.uniform1f(uni.sat, Number(fSat.value));
  gl.uniform1f(uni.hue, Number(fHue.value));
  gl.uniform1f(uni.blur, Number(fBlur.value));
  gl.uniform1f(uni.gray, fGray.checked ? 1 : 0);
  gl.uniform1f(uni.invert, fInvert.checked ? 1 : 0);

  // Draw to full canvas. We still need to show doc region with pan/zoom.
  // Simplest v1: draw full texture to canvas; then we position with CSS overlay is not possible.
  // Instead we render doc into composite already (doc size), and then draw a "camera" crop in UI layer.
  // Here we render full composite; UI overlay draws doc bounds. This keeps it simple.
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  // NOTE: v1 limitation: GL renders full composite stretched to stage.
  // To align with pan/zoom precisely, we'd implement a transform in shader.
  // For now we display filtered output as a background and draw edit overlays in correct coords.
}

// Request render scheduling
let needs = {composite:true, gl:true, ui:true};
let raf = 0;
function requestRender(){
  if (raf) return;
  raf = requestAnimationFrame(()=>{
    raf = 0;
    // Render UI canvas at correct size
    fitUICanvas();
    renderComposite();
    uploadComposite();
    renderGL();
    renderUI();
  });
}

function fitUICanvas(){
  const rect = stage.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  uiCanvas.width = Math.floor(rect.width * dpr);
  uiCanvas.height = Math.floor(rect.height * dpr);
  ctxUI.setTransform(dpr,0,0,dpr,0,0);
}

window.addEventListener("resize", ()=>requestRender());

// Filter controls
[
  fBright,fContrast,fSat,fHue,fBlur,fGray,fInvert
].forEach(el=>{
  el.addEventListener("input", ()=>requestRender());
  el.addEventListener("change", ()=>requestRender());
});
btnBypass.addEventListener("click", ()=>{
  bypass = !bypass;
  btnBypass.textContent = bypass ? "Un-bypass" : "Bypass";
  requestRender();
});
btnResetFilters.addEventListener("click", ()=>{
  fBright.value = 0;
  fContrast.value = 0;
  fSat.value = 0;
  fHue.value = 0;
  fBlur.value = 0;
  fGray.checked = false;
  fInvert.checked = false;
  bypass = false;
  btnBypass.textContent = "Bypass";
  requestRender();
});

// ============================================================
// Init
// ============================================================
function init(){
  // Start with a base layer
  newLayer("Layer 1");
  resizeDocument(doc.w, doc.h, true);
  sizeLabel.textContent = `${doc.w}√ó${doc.h}`;

  initGL();
  renderLayersUI();

  // initial history snapshot
  snapshot("init");
  updateUndoRedoButtons();
  requestRender();
}
init();

// ============================================================
// Helpers
// ============================================================
function cryptoId(){
  return Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2);
}
function escapeHtml(s){
  return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;");
}

// ============================================================
// IMPORTANT NOTE (v1 pan/zoom vs GL):
// This v1 shows the filtered composite as a fast background. The edit overlay (UI)
// uses the true pan/zoom transform, so tool placement is correct.
// Next iteration: implement pan/zoom in the WebGL shader (uniform transform)
// so filtered output lines up perfectly with the UI.
// ============================================================
</script>
</body>
</html>
