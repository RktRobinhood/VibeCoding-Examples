<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web Photo Editor (v1) ‚Äî Canvas + WebGL</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:rgba(255,255,255,.05);
      --panel2:rgba(255,255,255,.03);
      --border:rgba(255,255,255,.12);
      --ink:#e9ecff;
      --muted:rgba(233,236,255,.72);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--ink);
      background:
        radial-gradient(1100px 700px at 15% 10%, rgba(124,58,237,0.35), transparent 60%),
        radial-gradient(1100px 700px at 85% 12%, rgba(59,130,246,0.25), transparent 58%),
        linear-gradient(180deg, #070a14, var(--bg));
    }
    a{color:#9ac6ff;text-decoration:none}
    a:hover{text-decoration:underline}

    header{max-width:1400px;margin:0 auto;padding:14px 16px 8px}
    .topnav{margin-bottom:8px}
    h1{margin:0;font-size:18px}
    .sub{margin:8px 0 0;color:var(--muted);font-size:13px;line-height:1.4;max-width:1100px}

    main{max-width:1400px;margin:0 auto;padding:10px 16px 24px;display:grid;grid-template-columns: 320px 1fr 340px;gap:12px;align-items:start}
    @media (max-width:1200px){main{grid-template-columns:1fr}}

    .panel{
      border:1px solid var(--border);
      border-radius:16px;
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      box-shadow:0 10px 35px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .ph{padding:12px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .ph h2{margin:0;font-size:13px;letter-spacing:.2px}
    .pb{padding:12px}

    button, input[type="text"], select{
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--ink);
      border-radius:12px;
      padding:8px 10px;
      font-size:12px;
      outline:none;
    }
    button{cursor:pointer}
    button:hover{filter:brightness(1.07)}
    button.primary{background:rgba(124,58,237,.22);border-color:rgba(124,58,237,.55)}
    button.good{background:rgba(34,197,94,.16);border-color:rgba(34,197,94,.55)}
    button.warn{background:rgba(251,191,36,.14);border-color:rgba(251,191,36,.55)}
    button.bad{background:rgba(251,113,133,.14);border-color:rgba(251,113,133,.55)}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}

    .pill{display:inline-flex;gap:8px;align-items:center;font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,.04)}
    .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; padding:2px 6px;border:1px solid var(--border);border-radius:8px;background:rgba(255,255,255,0.05);font-size:12px}
    .hint{color:var(--muted);font-size:12px;line-height:1.4}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}

    .stageWrap{border:1px solid var(--border);border-radius:16px;overflow:hidden;background:rgba(0,0,0,.18)}
    .stageTop{
      padding:10px 12px;border-bottom:1px solid var(--border);
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
    }
    .stage{
      position:relative;
      width:100%;
      height:720px;
      background:
        linear-gradient(45deg, rgba(255,255,255,.05) 25%, transparent 25%, transparent 75%, rgba(255,255,255,.05) 75%, rgba(255,255,255,.05)),
        linear-gradient(45deg, rgba(255,255,255,.05) 25%, transparent 25%, transparent 75%, rgba(255,255,255,.05) 75%, rgba(255,255,255,.05));
      background-size: 24px 24px;
      background-position: 0 0, 12px 12px;
    }
    @media (max-width:1200px){.stage{height:560px}}
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block}
    #glCanvas{pointer-events:none}
    #uiCanvas{pointer-events:auto}
    .dropBadge{
      position:absolute;left:12px;bottom:12px;
      border:1px dashed rgba(255,255,255,.28);
      background:rgba(0,0,0,.25);
      color:rgba(233,236,255,.88);
      padding:10px 12px;border-radius:14px;font-size:12px;max-width:520px;
    }

    .layers{display:flex;flex-direction:column;gap:8px}
    .layer{
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(255,255,255,.03);
      padding:10px;
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px;
      align-items:center;
    }
    .layer.active{outline:2px solid rgba(124,58,237,.8);outline-offset:2px}
    .layer .title{display:flex;gap:8px;align-items:center;min-width:0}
    .layer input[type="text"]{width:100%;min-width:0}
    .layer .meta{display:flex;gap:8px;align-items:center;justify-content:flex-end}
    .miniBtn{padding:6px 8px;border-radius:10px}
    .slider{width:120px}

    .group{border:1px solid var(--border);border-radius:14px;padding:10px;background:rgba(255,255,255,.03)}
    .group h3{margin:0 0 8px;font-size:13px}
    .kv{display:grid;grid-template-columns: 140px 1fr;gap:8px;align-items:center;font-size:12px;color:rgba(233,236,255,.86)}
    .kv span{color:rgba(233,236,255,.7)}
    input[type="range"]{width:100%}
  </style>
</head>
<body>
  <header>
    <nav class="topnav"><a href="../../index.html">‚Üê Back to projects</a></nav>
    <h1>Web Photo Editor (v1) ‚Äî Canvas + WebGL</h1>
    <p class="sub">
      Layers, brush/eraser/shapes/text, pan/zoom, undo/redo, and fast WebGL filters.
      Pan: <span class="kbd">Space</span>+drag ‚Ä¢ Zoom: mouse wheel ‚Ä¢ Text: double-click to place.
    </p>
  </header>

  <main>
    <!-- LEFT -->
    <section class="panel">
      <div class="ph">
        <h2>Tools & layers</h2>
        <div class="row">
          <button id="btnImport" class="primary">Import</button>
          <input id="fileInput" type="file" accept="image/*" style="display:none" />
        </div>
      </div>
      <div class="pb">
        <div class="group">
          <h3>Tools</h3>
          <div class="row" style="margin-bottom:8px">
            <button id="toolMove" class="primary">Move</button>
            <button id="toolBrush">Brush</button>
            <button id="toolEraser">Eraser</button>
            <button id="toolRect">Rect</button>
            <button id="toolEllipse">Ellipse</button>
            <button id="toolText">Text</button>
          </div>

          <div class="kv"><span>Brush size</span><input id="brushSize" type="range" min="1" max="80" value="14" /></div>
          <div class="kv"><span>Brush hardness</span><input id="brushHard" type="range" min="0" max="100" value="70" /></div>
          <div class="kv"><span>Opacity</span><input id="brushOpacity" type="range" min="1" max="100" value="90" /></div>
          <div class="kv"><span>Color</span>
            <div class="row" style="justify-content:space-between">
              <input id="colorPick" type="color" value="#ffffff" />
              <span class="pill mono" id="colorHex">#ffffff</span>
            </div>
          </div>
          <div class="hint" style="margin-top:8px">
            Undo: <span class="kbd">Ctrl/‚åò</span>+<span class="kbd">Z</span> ‚Ä¢ Redo: <span class="kbd">Ctrl/‚åò</span>+<span class="kbd">Shift</span>+<span class="kbd">Z</span>
          </div>
        </div>

        <div class="group" style="margin-top:10px">
          <div class="row" style="justify-content:space-between;align-items:center">
            <h3 style="margin:0">Layers</h3>
            <div class="row">
              <button id="btnNewLayer" class="good miniBtn">+ Layer</button>
            </div>
          </div>
          <div class="layers" id="layers"></div>
          <div class="hint" style="margin-top:8px">
            Tip: import a base image, lock it, and draw on a layer above.
          </div>
        </div>
      </div>
    </section>

    <!-- CENTER -->
    <section class="panel stageWrap">
      <div class="stageTop">
        <div class="row">
          <button id="btnUndo">Undo</button>
          <button id="btnRedo">Redo</button>
          <button id="btnExport" class="good">Export PNG</button>
          <button id="btnResetView" class="warn">Reset view</button>
        </div>
        <div class="row">
          <span class="pill">Zoom: <span class="mono" id="zoomLabel">100%</span></span>
          <span class="pill">Canvas: <span class="mono" id="sizeLabel">‚Äî</span></span>
        </div>
      </div>
      <div class="stage" id="stage">
        <canvas id="glCanvas"></canvas>
        <canvas id="uiCanvas"></canvas>
        <div class="dropBadge" id="dropBadge">
          Drop an image here to import. Pan: <span class="kbd">Space</span>+drag ‚Ä¢ Zoom: wheel ‚Ä¢ Text: double-click
        </div>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="panel">
      <div class="ph">
        <h2>WebGL filters</h2>
        <div class="row">
          <button id="btnBypass">Bypass</button>
          <button id="btnResetFilters" class="warn">Reset</button>
        </div>
      </div>
      <div class="pb">
        <div class="group">
          <h3>Adjustments</h3>
          <div class="kv"><span>Brightness</span><input id="fBright" type="range" min="-1" max="1" value="0" step="0.01"></div>
          <div class="kv"><span>Contrast</span><input id="fContrast" type="range" min="-1" max="1" value="0" step="0.01"></div>
          <div class="kv"><span>Saturation</span><input id="fSat" type="range" min="-1" max="2" value="0" step="0.01"></div>
          <div class="kv"><span>Hue</span><input id="fHue" type="range" min="-3.1416" max="3.1416" value="0" step="0.01"></div>
        </div>

        <div class="group" style="margin-top:10px">
          <h3>Effects</h3>
          <div class="kv"><span>Blur</span><input id="fBlur" type="range" min="0" max="8" value="0" step="0.1"></div>
          <div class="row" style="margin-top:8px">
            <label class="pill"><input id="fGray" type="checkbox"> Grayscale</label>
            <label class="pill"><input id="fInvert" type="checkbox"> Invert</label>
          </div>
          <div class="hint" style="margin-top:8px">
            Filters apply to the full composite in v1.
          </div>
        </div>
      </div>
    </section>
  </main>

<script>
/* ============================================================
   Web Photo Editor v1 (Canvas 2D + WebGL)
   ============================================================ */

const $ = (s)=>document.querySelector(s);
const stage = $("#stage");
const glCanvas = $("#glCanvas");
const uiCanvas = $("#uiCanvas");
const ctxUI = uiCanvas.getContext("2d", { alpha: true });

const btnImport = $("#btnImport");
const fileInput = $("#fileInput");
const btnNewLayer = $("#btnNewLayer");
const layersEl = $("#layers");

const toolMove = $("#toolMove");
const toolBrush = $("#toolBrush");
const toolEraser = $("#toolEraser");
const toolRect = $("#toolRect");
const toolEllipse = $("#toolEllipse");
const toolText = $("#toolText");

const brushSize = $("#brushSize");
const brushHard = $("#brushHard");
const brushOpacity = $("#brushOpacity");
const colorPick = $("#colorPick");
const colorHex = $("#colorHex");

const btnUndo = $("#btnUndo");
const btnRedo = $("#btnRedo");
const btnExport = $("#btnExport");
const btnResetView = $("#btnResetView");
const zoomLabel = $("#zoomLabel");
const sizeLabel = $("#sizeLabel");
const dropBadge = $("#dropBadge");

const btnBypass = $("#btnBypass");
const btnResetFilters = $("#btnResetFilters");
const fBright = $("#fBright");
const fContrast = $("#fContrast");
const fSat = $("#fSat");
const fHue = $("#fHue");
const fBlur = $("#fBlur");
const fGray = $("#fGray");
const fInvert = $("#fInvert");

let TOOL = "move";
let bypass = false;

const doc = { w: 1200, h: 800 };
const view = { zoom: 1, panX: 0, panY: 0, isPanning: false, panStart: {x:0,y:0, px:0, py:0} };

function setZoom(z){
  view.zoom = Math.max(0.1, Math.min(8, z));
  zoomLabel.textContent = Math.round(view.zoom * 100) + "%";
  requestRender();
}
function resetView(){
  view.zoom = 1;
  view.panX = 0;
  view.panY = 0;
  zoomLabel.textContent = "100%";
  requestRender();
}
btnResetView.addEventListener("click", resetView);

colorPick.addEventListener("input", ()=> colorHex.textContent = colorPick.value.toLowerCase());

/* ---------------- LAYERS ---------------- */
const layers = [];
let activeLayerId = null;

function newLayer(name="Layer"){
  const id = cryptoId();
  const c = document.createElement("canvas");
  c.width = doc.w; c.height = doc.h;
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);

  const layer = { id, name, canvas:c, ctx, visible:true, locked:false, opacity:1, x:0, y:0 };
  layers.unshift(layer);
  activeLayerId = id;
  snapshot("new layer");
  renderLayersUI();
  requestRender();
  return layer;
}
function getActiveLayer(){ return layers.find(l => l.id === activeLayerId) || layers[0]; }

function renderLayersUI(){
  layersEl.innerHTML = "";
  for (const l of layers){
    const row = document.createElement("div");
    row.className = "layer" + (l.id===activeLayerId ? " active" : "");
    row.innerHTML = `
      <div class="title">
        <button class="miniBtn" data-act="vis" title="Show/hide">${l.visible ? "üëÅ" : "üö´"}</button>
        <input type="text" value="${escapeHtml(l.name)}" data-act="name" />
      </div>
      <div class="meta">
        <label class="pill" title="Opacity"><span class="mono">${Math.round(l.opacity*100)}%</span>
          <input class="slider" type="range" min="0" max="100" value="${Math.round(l.opacity*100)}" data-act="op"/>
        </label>
        <button class="miniBtn" data-act="up" title="Move up">‚Üë</button>
        <button class="miniBtn" data-act="dn" title="Move down">‚Üì</button>
        <button class="miniBtn" data-act="lock" title="Lock/unlock">${l.locked ? "üîí" : "üîì"}</button>
        <button class="miniBtn bad" data-act="del" title="Delete">‚úï</button>
      </div>
    `;
    row.addEventListener("mousedown", ()=>{ activeLayerId=l.id; renderLayersUI(); requestRender(); });

    row.querySelector('[data-act="vis"]').addEventListener("click", (e)=>{ e.stopPropagation(); l.visible=!l.visible; renderLayersUI(); requestRender(); });
    row.querySelector('[data-act="lock"]').addEventListener("click",(e)=>{ e.stopPropagation(); l.locked=!l.locked; renderLayersUI(); });
    row.querySelector('[data-act="del"]').addEventListener("click",(e)=>{
      e.stopPropagation();
      if (layers.length<=1) return alert("Keep at least one layer.");
      const idx = layers.findIndex(x=>x.id===l.id);
      layers.splice(idx,1);
      if (activeLayerId===l.id) activeLayerId = layers[0].id;
      snapshot("delete layer");
      renderLayersUI();
      requestRender();
    });
    row.querySelector('[data-act="up"]').addEventListener("click",(e)=>{
      e.stopPropagation();
      const idx = layers.findIndex(x=>x.id===l.id);
      if (idx<=0) return;
      [layers[idx-1], layers[idx]] = [layers[idx], layers[idx-1]];
      snapshot("reorder"); renderLayersUI(); requestRender();
    });
    row.querySelector('[data-act="dn"]').addEventListener("click",(e)=>{
      e.stopPropagation();
      const idx = layers.findIndex(x=>x.id===l.id);
      if (idx<0 || idx>=layers.length-1) return;
      [layers[idx+1], layers[idx]] = [layers[idx], layers[idx+1]];
      snapshot("reorder"); renderLayersUI(); requestRender();
    });
    row.querySelector('[data-act="op"]').addEventListener("input",(e)=>{
      e.stopPropagation();
      l.opacity = Number(e.target.value)/100;
      renderLayersUI(); requestRender();
    });
    row.querySelector('[data-act="name"]').addEventListener("input",(e)=>{
      e.stopPropagation();
      l.name = e.target.value.slice(0,60);
    });

    layersEl.appendChild(row);
  }
}

btnNewLayer.addEventListener("click", ()=> newLayer(`Layer ${layers.length+1}`));

/* ---------------- COMPOSITE ---------------- */
const composite = document.createElement("canvas");
const ctxC = composite.getContext("2d");

function resizeDocument(w,h, preserve=true){
  doc.w = Math.max(1, Math.floor(w));
  doc.h = Math.max(1, Math.floor(h));
  sizeLabel.textContent = `${doc.w}√ó${doc.h}`;

  composite.width = doc.w;
  composite.height = doc.h;

  for (const l of layers){
    const old = l.canvas;
    const c = document.createElement("canvas");
    c.width = doc.w; c.height = doc.h;
    const ctx = c.getContext("2d");
    if (preserve) ctx.drawImage(old, 0,0);
    l.canvas = c;
    l.ctx = ctx;
  }
  requestRender();
}

function renderComposite(){
  composite.width = doc.w;
  composite.height = doc.h;
  ctxC.clearRect(0,0,doc.w,doc.h);
  ctxC.save();
  for (const l of [...layers].reverse()){
    if (!l.visible) continue;
    ctxC.globalAlpha = l.opacity;
    ctxC.drawImage(l.canvas, l.x, l.y);
  }
  ctxC.restore();
}

/* ---------------- HISTORY ---------------- */
const history = { undo: [], redo: [], max: 20 };

function snapshot(reason="edit"){
  const state = {
    doc: {w:doc.w, h:doc.h},
    layers: layers.map(l => ({
      id:l.id, name:l.name, visible:l.visible, locked:l.locked, opacity:l.opacity, x:l.x, y:l.y,
      png: l.canvas.toDataURL("image/png")
    })),
    activeLayerId,
    reason
  };
  history.undo.push(state);
  if (history.undo.length > history.max) history.undo.shift();
  history.redo = [];
  updateUndoRedoButtons();
}

function applyState(state){
  resizeDocument(state.doc.w, state.doc.h, false);
  layers.length = 0;

  for (const L of state.layers){
    const c = document.createElement("canvas");
    c.width = doc.w; c.height = doc.h;
    const ctx = c.getContext("2d");
    layers.push({
      id:L.id, name:L.name, visible:L.visible, locked:L.locked, opacity:L.opacity, x:L.x, y:L.y,
      canvas:c, ctx
    });
  }

  let remaining = state.layers.length;
  state.layers.forEach((L, idx)=>{
    const img = new Image();
    img.onload = ()=>{
      layers[idx].ctx.clearRect(0,0,doc.w,doc.h);
      layers[idx].ctx.drawImage(img,0,0);
      remaining--;
      if (remaining===0){
        activeLayerId = state.activeLayerId;
        renderLayersUI();
        requestRender();
      }
    };
    img.src = L.png;
  });
}

function undo(){
  if (history.undo.length<=1) return;
  const cur = history.undo.pop();
  history.redo.push(cur);
  applyState(history.undo[history.undo.length-1]);
  updateUndoRedoButtons();
}
function redo(){
  if (!history.redo.length) return;
  const s = history.redo.pop();
  history.undo.push(s);
  applyState(s);
  updateUndoRedoButtons();
}
function updateUndoRedoButtons(){
  btnUndo.disabled = history.undo.length<=1;
  btnRedo.disabled = history.redo.length===0;
}
btnUndo.onclick = undo;
btnRedo.onclick = redo;

/* ---------------- KEYBINDS ---------------- */
window.addEventListener("keydown",(e)=>{
  const isMac = navigator.platform.toLowerCase().includes("mac");
  const mod = isMac ? e.metaKey : e.ctrlKey;
  if (mod && e.key.toLowerCase()==="z" && !e.shiftKey){ e.preventDefault(); undo(); }
  if (mod && e.key.toLowerCase()==="z" && e.shiftKey){ e.preventDefault(); redo(); }
  if (e.code==="Space" && !e.repeat) view.isPanning = true;
});
window.addEventListener("keyup",(e)=>{ if (e.code==="Space") view.isPanning = false; });

/* ---------------- TOOLS ---------------- */
function setTool(t){
  TOOL = t;
  [toolMove,toolBrush,toolEraser,toolRect,toolEllipse,toolText].forEach(b=>b.classList.remove("primary"));
  ({move:toolMove, brush:toolBrush, eraser:toolEraser, rect:toolRect, ellipse:toolEllipse, text:toolText}[t])
    .classList.add("primary");
  requestRender();
}
toolMove.onclick=()=>setTool("move");
toolBrush.onclick=()=>setTool("brush");
toolEraser.onclick=()=>setTool("eraser");
toolRect.onclick=()=>setTool("rect");
toolEllipse.onclick=()=>setTool("ellipse");
toolText.onclick=()=>setTool("text");

/* ---------------- IMPORT ---------------- */
btnImport.addEventListener("click", ()=>fileInput.click());
fileInput.addEventListener("change", async ()=>{
  const f = fileInput.files?.[0];
  if (!f) return;
  await importImageFile(f);
  fileInput.value = "";
});

async function importImageFile(file){
  const url = URL.createObjectURL(file);
  const img = await loadImage(url);
  URL.revokeObjectURL(url);

  if (layers.length===1 && isLayerEmpty(layers[0])) resizeDocument(img.width, img.height, false);

  const layer = newLayer(file.name.replace(/\.[^.]+$/,""));
  layer.ctx.clearRect(0,0,doc.w,doc.h);
  layer.ctx.drawImage(img, 0,0);
  dropBadge.style.display = "none";

  snapshot("import");
  requestRender();
}

stage.addEventListener("dragover", (e)=>{ e.preventDefault(); });
stage.addEventListener("drop", async (e)=>{
  e.preventDefault();
  const f = e.dataTransfer?.files?.[0];
  if (f && f.type.startsWith("image/")) await importImageFile(f);
});

function isLayerEmpty(layer){
  const img = layer.ctx.getImageData(0,0,Math.min(32,doc.w),Math.min(32,doc.h)).data;
  for (let i=3;i<img.length;i+=4) if (img[i]!==0) return false;
  return true;
}
function loadImage(src){
  return new Promise((res,rej)=>{
    const im = new Image();
    im.onload=()=>res(im);
    im.onerror=rej;
    im.src = src;
  });
}

/* ---------------- COORDS ---------------- */
function screenToDoc(x,y){
  const cx = uiCanvas.clientWidth/2;
  const cy = uiCanvas.clientHeight/2;
  const dx = (x - cx - view.panX) / view.zoom + doc.w/2;
  const dy = (y - cy - view.panY) / view.zoom + doc.h/2;
  return {x:dx, y:dy};
}
function docToScreen(x,y){
  const cx = uiCanvas.clientWidth/2;
  const cy = uiCanvas.clientHeight/2;
  const sx = (x - doc.w/2) * view.zoom + cx + view.panX;
  const sy = (y - doc.h/2) * view.zoom + cy + view.panY;
  return {x:sx, y:sy};
}

/* ---------------- DRAWING ---------------- */
let mouse = {down:false, x:0,y:0, lastX:0,lastY:0};
let dragLayer = null;
let shapeStart = null;
let shapePreview = null;

uiCanvas.addEventListener("wheel", (e)=>{
  e.preventDefault();
  const delta = Math.sign(e.deltaY);
  const factor = delta>0 ? 0.92 : 1.08;
  setZoom(view.zoom * factor);
},{passive:false});

uiCanvas.addEventListener("mousedown",(e)=>{
  mouse.down=true;
  mouse.x = mouse.lastX = e.offsetX;
  mouse.y = mouse.lastY = e.offsetY;

  if (view.isPanning){
    view.panStart = {x:e.clientX,y:e.clientY, px:view.panX, py:view.panY};
    return;
  }

  const a = getActiveLayer();
  if (!a || a.locked) return;

  if (TOOL==="move") dragLayer = a;
  else if (TOOL==="brush" || TOOL==="eraser") drawStrokeToLayer(a, e.offsetX, e.offsetY, true);
  else if (TOOL==="rect" || TOOL==="ellipse"){ shapeStart={sx:e.offsetX, sy:e.offsetY}; shapePreview=null; }
});

uiCanvas.addEventListener("mousemove",(e)=>{
  mouse.x=e.offsetX; mouse.y=e.offsetY;

  if (mouse.down && view.isPanning){
    const dx = e.clientX - view.panStart.x;
    const dy = e.clientY - view.panStart.y;
    view.panX = view.panStart.px + dx;
    view.panY = view.panStart.py + dy;
    requestRender(); return;
  }

  if (!mouse.down){ requestRender(); return; }

  const a = getActiveLayer();
  if (!a || a.locked) return;

  if (TOOL==="move" && dragLayer){
    const dScreenX = e.offsetX - mouse.lastX;
    const dScreenY = e.offsetY - mouse.lastY;
    dragLayer.x += dScreenX / view.zoom;
    dragLayer.y += dScreenY / view.zoom;
    requestRender();
  } else if (TOOL==="brush" || TOOL==="eraser"){
    drawStrokeToLayer(a, e.offsetX, e.offsetY, false);
  } else if ((TOOL==="rect" || TOOL==="ellipse") && shapeStart){
    shapePreview = {ex:e.offsetX, ey:e.offsetY};
    requestRender();
  }

  mouse.lastX=e.offsetX; mouse.lastY=e.offsetY;
});

uiCanvas.addEventListener("mouseup",()=>{
  mouse.down=false;
  dragLayer=null;

  const a = getActiveLayer();

  if ((TOOL==="rect" || TOOL==="ellipse") && shapeStart && shapePreview && a && !a.locked){
    commitShape(a, shapeStart, shapePreview, TOOL);
    shapeStart=null; shapePreview=null;
    snapshot("shape");
  } else { shapeStart=null; shapePreview=null; }

  if (TOOL==="brush" || TOOL==="eraser") snapshot("stroke");
  if (TOOL==="move") snapshot("move");
});

uiCanvas.addEventListener("dblclick",(e)=>{
  if (TOOL!=="text") return;
  const a = getActiveLayer();
  if (!a || a.locked) return;
  const t = prompt("Text:", "Label");
  if (!t) return;
  const pt = screenToDoc(e.offsetX, e.offsetY);

  a.ctx.save();
  a.ctx.globalAlpha = Number(brushOpacity.value)/100;
  a.ctx.fillStyle = colorPick.value;
  a.ctx.font = `700 ${Math.max(12, Number(brushSize.value)+6)}px ui-sans-serif, system-ui`;
  a.ctx.textBaseline = "top";
  a.ctx.fillText(t, pt.x - a.x, pt.y - a.y);
  a.ctx.restore();

  snapshot("text");
  requestRender();
});

function drawStrokeToLayer(layer, sx, sy, isStart){
  const pt = screenToDoc(sx, sy);
  const x = pt.x - layer.x;
  const y = pt.y - layer.y;

  const size = Number(brushSize.value);
  const hard = Number(brushHard.value)/100;
  const alpha = Number(brushOpacity.value)/100;

  layer.ctx.save();
  layer.ctx.globalAlpha = alpha;
  layer.ctx.lineCap = "round";
  layer.ctx.lineJoin = "round";
  layer.ctx.lineWidth = size;

  if (TOOL==="eraser"){
    layer.ctx.globalCompositeOperation = "destination-out";
    layer.ctx.strokeStyle = "rgba(0,0,0,1)";
  } else {
    layer.ctx.globalCompositeOperation = "source-over";
    layer.ctx.strokeStyle = colorPick.value;
  }

  if (isStart){
    layer._last = {x,y};
    softDab(layer.ctx, x,y, size, hard, (TOOL==="eraser"));
  } else {
    const last = layer._last || {x,y};
    layer.ctx.beginPath();
    layer.ctx.moveTo(last.x, last.y);
    layer.ctx.lineTo(x,y);
    layer.ctx.stroke();
    softDab(layer.ctx, x,y, size, hard, (TOOL==="eraser"));
    layer._last = {x,y};
  }

  layer.ctx.restore();
  requestRender();
}

function softDab(ctx, x,y, size, hard, erasing){
  const r = size/2;
  const g = ctx.createRadialGradient(x,y, r*hard, x,y, r);
  if (erasing){
    g.addColorStop(0, "rgba(0,0,0,1)");
    g.addColorStop(1, "rgba(0,0,0,0)");
  } else {
    const c = colorPick.value;
    g.addColorStop(0, hexToRgba(c, 1));
    g.addColorStop(1, hexToRgba(c, 0));
  }
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
}

function commitShape(layer, start, end, kind){
  const p1 = screenToDoc(start.sx, start.sy);
  const p2 = screenToDoc(end.ex, end.ey);

  const x1 = Math.min(p1.x,p2.x) - layer.x;
  const y1 = Math.min(p1.y,p2.y) - layer.y;
  const x2 = Math.max(p1.x,p2.x) - layer.x;
  const y2 = Math.max(p1.y,p2.y) - layer.y;

  layer.ctx.save();
  layer.ctx.globalAlpha = Number(brushOpacity.value)/100;
  layer.ctx.globalCompositeOperation = "source-over";
  layer.ctx.strokeStyle = colorPick.value;
  layer.ctx.lineWidth = Math.max(2, Number(brushSize.value)/6);

  if (kind==="rect"){
    layer.ctx.strokeRect(x1,y1,x2-x1,y2-y1);
  } else {
    layer.ctx.beginPath();
    layer.ctx.ellipse((x1+x2)/2,(y1+y2)/2, Math.abs(x2-x1)/2, Math.abs(y2-y1)/2, 0, 0, Math.PI*2);
    layer.ctx.stroke();
  }
  layer.ctx.restore();
  requestRender();
}

function hexToRgba(hex,a){
  const m = hex.replace("#","").match(/.{1,2}/g);
  const [r,g,b] = m.map(x=>parseInt(x,16));
  return `rgba(${r},${g},${b},${a})`;
}

/* ---------------- EXPORT ---------------- */
btnExport.addEventListener("click", ()=>{
  renderComposite();
  uploadComposite();
  renderGL();
  const link = document.createElement("a");
  link.download = "export.png";
  link.href = (gl ? glCanvas.toDataURL("image/png") : composite.toDataURL("image/png"));
  link.click();
});

/* ============================================================
   WebGL Helpers (FIXED: missing createProgram)
   ============================================================ */
function compileShader(gl, type, src) {
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
    const log = gl.getShaderInfoLog(sh) || "(no log)";
    gl.deleteShader(sh);
    throw new Error("Shader compile failed:\n" + log);
  }
  return sh;
}
function createProgram(gl, vsSrc, fsSrc) {
  const vs = compileShader(gl, gl.VERTEX_SHADER, vsSrc);
  const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSrc);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  gl.deleteShader(vs);
  gl.deleteShader(fs);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    const log = gl.getProgramInfoLog(prog) || "(no log)";
    gl.deleteProgram(prog);
    throw new Error("Program link failed:\n" + log);
  }
  return prog;
}

/* ---------------- WEBGL PIPELINE ---------------- */
let gl = null, prog = null, vao = null, tex = null, uni = null;

function initGL(){
  try{
    gl = glCanvas.getContext("webgl2", { premultipliedAlpha: true, alpha: true });
    if (!gl){
      console.warn("WebGL2 not available; filters disabled (Canvas-only fallback).");
      gl = null;
      return;
    }

    const vs = `#version 300 es
    precision highp float;
    in vec2 a_pos;
    out vec2 v_uv;
    void main(){
      v_uv = (a_pos + 1.0) * 0.5;
      gl_Position = vec4(a_pos, 0.0, 1.0);
    }`;

    const fs = `#version 300 es
    precision highp float;
    in vec2 v_uv;
    out vec4 outColor;
    uniform sampler2D u_tex;
    uniform vec2 u_texSize;

    uniform float u_bypass;
    uniform float u_brightness;
    uniform float u_contrast;
    uniform float u_saturation;
    uniform float u_hue;
    uniform float u_blur;
    uniform float u_gray;
    uniform float u_invert;

    mat3 hueMat(float a){
      float c = cos(a);
      float s = sin(a);
      mat3 m = mat3(
        0.299, 0.587, 0.114,
        0.596, -0.274, -0.322,
        0.211, -0.523, 0.312
      );
      mat3 inv = inverse(m);
      mat3 rot = mat3(
        1.0, 0.0, 0.0,
        0.0, c, -s,
        0.0, s,  c
      );
      return inv * rot * m;
    }

    vec3 applyAdjust(vec3 col){
      col += u_brightness;
      float cc = u_contrast + 1.0;
      col = (col - 0.5) * cc + 0.5;
      float l = dot(col, vec3(0.2126,0.7152,0.0722));
      col = mix(vec3(l), col, (u_saturation + 1.0));
      col = hueMat(u_hue) * col;

      if (u_gray > 0.5){
        float g = dot(col, vec3(0.2126,0.7152,0.0722));
        col = vec3(g);
      }
      if (u_invert > 0.5){
        col = vec3(1.0) - col;
      }
      return col;
    }

    void main(){
      vec2 uv = v_uv;

      vec4 base = texture(u_tex, uv);

      if (u_bypass > 0.5){
        outColor = base;
        return;
      }

      vec4 col = base;
      if (u_blur > 0.001){
        vec2 px = 1.0 / u_texSize;
        float r = u_blur;
        vec2 o1 = px * r;
        vec2 o2 = px * r * 0.7071;

        vec4 s = texture(u_tex, uv) * 0.24;
        s += texture(u_tex, uv + vec2( o1.x, 0.0)) * 0.12;
        s += texture(u_tex, uv + vec2(-o1.x, 0.0)) * 0.12;
        s += texture(u_tex, uv + vec2(0.0,  o1.y)) * 0.12;
        s += texture(u_tex, uv + vec2(0.0, -o1.y)) * 0.12;

        s += texture(u_tex, uv + vec2( o2.x,  o2.y)) * 0.07;
        s += texture(u_tex, uv + vec2(-o2.x,  o2.y)) * 0.07;
        s += texture(u_tex, uv + vec2( o2.x, -o2.y)) * 0.07;
        s += texture(u_tex, uv + vec2(-o2.x, -o2.y)) * 0.07;
        col = s;
      }

      vec3 adj = applyAdjust(col.rgb);
      outColor = vec4(adj, col.a);
    }`;

    prog = createProgram(gl, vs, fs);
    gl.useProgram(prog);

    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1,-1,  1,-1, -1, 1,
      -1, 1,  1,-1,  1, 1
    ]), gl.STATIC_DRAW);

    const loc = gl.getAttribLocation(prog, "a_pos");
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

    tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    uni = {
      texSize: gl.getUniformLocation(prog, "u_texSize"),
      bypass: gl.getUniformLocation(prog, "u_bypass"),
      bright: gl.getUniformLocation(prog, "u_brightness"),
      contrast: gl.getUniformLocation(prog, "u_contrast"),
      sat: gl.getUniformLocation(prog, "u_saturation"),
      hue: gl.getUniformLocation(prog, "u_hue"),
      blur: gl.getUniformLocation(prog, "u_blur"),
      gray: gl.getUniformLocation(prog, "u_gray"),
      invert: gl.getUniformLocation(prog, "u_invert"),
    };

    gl.uniform1i(gl.getUniformLocation(prog,"u_tex"), 0);
  } catch (err){
    console.error(err);
    gl = null; prog=null; vao=null; tex=null; uni=null;
  }
}

function uploadComposite(){
  if (!gl || !tex || !uni) return;
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, composite);
  gl.uniform2f(uni.texSize, composite.width, composite.height);
}

function renderGL(){
  if (!gl || !prog || !vao || !tex || !uni) return;

  const rect = stage.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  glCanvas.width = Math.floor(rect.width * dpr);
  glCanvas.height = Math.floor(rect.height * dpr);

  gl.viewport(0,0,glCanvas.width, glCanvas.height);
  gl.clearColor(0,0,0,0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.useProgram(prog);
  gl.bindVertexArray(vao);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, tex);

  gl.uniform1f(uni.bypass, bypass ? 1 : 0);
  gl.uniform1f(uni.bright, Number(fBright.value));
  gl.uniform1f(uni.contrast, Number(fContrast.value));
  gl.uniform1f(uni.sat, Number(fSat.value));
  gl.uniform1f(uni.hue, Number(fHue.value));
  gl.uniform1f(uni.blur, Number(fBlur.value));
  gl.uniform1f(uni.gray, fGray.checked ? 1 : 0);
  gl.uniform1f(uni.invert, fInvert.checked ? 1 : 0);

  gl.drawArrays(gl.TRIANGLES, 0, 6);
}

/* ---------------- UI OVERLAYS ---------------- */
function renderUI(){
  const W = uiCanvas.clientWidth;
  const H = uiCanvas.clientHeight;
  ctxUI.clearRect(0,0,W,H);

  const tl = docToScreen(0,0);
  const br = docToScreen(doc.w, doc.h);

  ctxUI.save();
  ctxUI.strokeStyle = "rgba(233,236,255,0.28)";
  ctxUI.lineWidth = 1;
  ctxUI.strokeRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);
  ctxUI.restore();

  if (shapeStart && shapePreview){
    const p1 = screenToDoc(shapeStart.sx, shapeStart.sy);
    const p2 = screenToDoc(shapePreview.ex, shapePreview.ey);
    const x1 = Math.min(p1.x,p2.x), y1 = Math.min(p1.y,p2.y);
    const x2 = Math.max(p1.x,p2.x), y2 = Math.max(p1.y,p2.y);
    const s1 = docToScreen(x1,y1);
    const s2 = docToScreen(x2,y2);

    ctxUI.save();
    ctxUI.strokeStyle = "rgba(251,191,36,0.9)";
    ctxUI.lineWidth = 2;
    if (TOOL==="rect"){
      ctxUI.strokeRect(s1.x,s1.y,s2.x-s1.x,s2.y-s1.y);
    } else if (TOOL==="ellipse"){
      ctxUI.beginPath();
      ctxUI.ellipse((s1.x+s2.x)/2,(s1.y+s2.y)/2, Math.abs(s2.x-s1.x)/2, Math.abs(s2.y-s1.y)/2, 0, 0, Math.PI*2);
      ctxUI.stroke();
    }
    ctxUI.restore();
  }

  ctxUI.save();
  ctxUI.fillStyle = "rgba(233,236,255,0.75)";
  ctxUI.font = "12px ui-sans-serif, system-ui";
  ctxUI.fillText(`Tool: ${TOOL.toUpperCase()}${view.isPanning ? " (PANNING)" : ""}`, 12, 18);
  ctxUI.fillText(`Layer: ${getActiveLayer()?.name ?? "‚Äî"}`, 12, 36);
  ctxUI.restore();
}

/* ---------------- RENDER LOOP ---------------- */
let raf = 0;
function requestRender(){
  if (raf) return;
  raf = requestAnimationFrame(()=>{
    raf = 0;
    fitUICanvas();
    renderComposite();
    uploadComposite();
    renderGL();
    renderUI();
  });
}
function fitUICanvas(){
  const rect = stage.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  uiCanvas.width = Math.floor(rect.width * dpr);
  uiCanvas.height = Math.floor(rect.height * dpr);
  ctxUI.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener("resize", ()=>requestRender());

/* ---------------- FILTER CONTROLS ---------------- */
[fBright,fContrast,fSat,fHue,fBlur,fGray,fInvert].forEach(el=>{
  el.addEventListener("input", ()=>requestRender());
  el.addEventListener("change", ()=>requestRender());
});
btnBypass.addEventListener("click", ()=>{
  bypass = !bypass;
  btnBypass.textContent = bypass ? "Un-bypass" : "Bypass";
  requestRender();
});
btnResetFilters.addEventListener("click", ()=>{
  fBright.value = 0;
  fContrast.value = 0;
  fSat.value = 0;
  fHue.value = 0;
  fBlur.value = 0;
  fGray.checked = false;
  fInvert.checked = false;
  bypass = false;
  btnBypass.textContent = "Bypass";
  requestRender();
});

/* ---------------- INIT ---------------- */
function init(){
  newLayer("Layer 1");
  resizeDocument(doc.w, doc.h, true);
  initGL();
  snapshot("init");
  updateUndoRedoButtons();
  requestRender();
}
init();

/* ---------------- HELPERS ---------------- */
function cryptoId(){ return Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2); }
function escapeHtml(s){ return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;"); }
</script>
</body>
</html>
